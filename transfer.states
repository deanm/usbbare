
// 8.4.6.4 Function Response to a SETUP Transaction
//   Upon receiving a SETUP token, a function must accept the data. A function
//   may not respond to a SETUP token with either STALL or NAK, and the
//   receiving function must accept the data packet that follows the SETUP
//   token. If a non-control endpoint receives a SETUP token, it must ignore
//   the transaction and return no response.
state setup_transaction0 : packet : addr, endp {
  want SETUP ADDR:addr EndPoint:endp {
    transition setup_transaction1 addr endp;
  }
}

state setup_transaction1 : packet : addr, endp {
  want DATA0 data.length:8 parse:setup {
    transition setup_transaction2 addr endp setup;
  }
  need {
    emit FailedSetupTransaction addr endp null;
    restart setup_transaction0 addr endp;
  }
}

state setup_transaction2 : packet : addr, endp, setup, bytes_left, bytes {
  want ACK {
    emit SetupTransaction addr endp setup;
    transition setup_transaction0 addr endp;
  }
  need {
    emit FailedSetupTransaction addr endp setup;
    restart setup_transaction0 addr endp;
  }
}

state bulk_transaction_in0 : packet :addr, endp {
  want IN ADDR:addr EndPoint:endp {
    transition bulk_transaction_in1 addr endp;
  }
}

state bulk_transaction_in1 : packet : addr, endp {
  want NAK {
    restart bulk_transaction_in0 addr endp;
  }
  need pid_type:DATA {
    transition bulk_transaction_in2 addr endp data;
  }
}

state bulk_transaction_in2 : packet : addr, endp, bytes {
  need ACK {
    emit BulkTransactionIn addr endp bytes;
    restart bulk_transaction_in0 addr endp;
  }
}

state bulk_transaction_out0 : packet : addr, endp {
  want OUT ADDR:addr EndPoint:endp {
    transition bulk_transaction_out1 addr endp;
  }
}

state bulk_transaction_out1 : packet : addr, endp {
  want NAK {
    restart bulk_transaction_out0 addr endp;
  }
  need pid_type:DATA {
    transition bulk_transaction_out2 addr endp data;
  }
}

state bulk_transaction_out2 : packet : addr, endp, bytes {
  need ACK {
    emit BulkTransactionOut addr endp bytes;
    restart bulk_transaction_out0 addr endp;
  }
}

state control_transfer_start : transaction : addr, endp {
  want parse:SetupTransaction ADDR:addr EndPoint:endp {
    want bmRequestType.transferDirection:0 {  // HostToDevice
      transition control_transfer_datastage_out0 addr endp SetupTransaction wLength nil;
    }
    need bmRequestType.transferDirection:1 {  // DeviceToHost
      transition control_transfer_datastage_in0 addr endp SetupTransaction wLength nil;
    }
  }
}

state control_transfer_datastage_in0 : transaction : addr, endp, setup, bytes_left, bytes {
  want ADDR:addr EndPoint:endp {
    want bytes_left:0 {  // stage stage
      need parse:BulkTransactionOut data.length:0 {
        emit ControlTransferIn addr endp setup bytes;
        transition control_transfer_start addr endp;
      }
    }
    need parse:BulkTransactionIn {
      dec bytes_left data.length;
      append bytes data;
      transition control_transfer_datastage_in0 addr endp setup bytes_left bytes;
    }
  }
}

state control_transfer_datastage_out0 : transaction : addr, endp, setup, bytes_left, bytes {
  want ADDR:addr EndPoint:endp {
    want bytes_left:0 {  // status stage
      need parse:BulkTransactionIn data.length:0 {
        emit ControlTransferOut addr endp setup bytes;
        restart control_transfer_start addr endp;
      }
    }
    need parse:BulkTransactionOut {
      dec bytes_left data.length;
      append bytes data;
      transition control_transfer_datastage_out0 addr endp setup bytes_left bytes;
    }
  }
}
