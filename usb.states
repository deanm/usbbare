
// 8.4.6.4 Function Response to a SETUP Transaction
//   Upon receiving a SETUP token, a function must accept the data. A function
//   may not respond to a SETUP token with either STALL or NAK, and the
//   receiving function must accept the data packet that follows the SETUP
//   token. If a non-control endpoint receives a SETUP token, it must ignore
//   the transaction and return no response.
transaction SetupTransaction : ADDR, EndPoint, setup {
  state setup_run {
    want SSPLIT {
      spawn setup_run;
      transition ssplit_setup HubAddr Port;
    }

    want SETUP {
      spawn setup_run;
      capture ADDR ADDR;
      capture EndPoint EndPoint;
      transition setup_data;
    }
  }

  state setup_data {
    need DATA0 data.length:8 parse:setup {
      capture setup setup;
      transition setup_ack;
    }
  }

  state ssplit_setup : hub, port {
    want SETUP {
      capture ADDR ADDR;
      capture EndPoint EndPoint;
      transition ssplit_setup_data ADDR EndPoint hub port;
    }
    need {
      die;  // Don't cause a failed transaction just from the SSPLIT.
    }
  }

  state ssplit_setup_data : addr, endp, hub, port {
    need DATA0 data.length:8 parse:setup {
      capture setup setup;
      transition ssplit_setup_ack addr endp hub port;
    }
  }

  state ssplit_setup_ack : addr, endp, hub, port {
    need ACK {
      transition csplit addr endp hub port;
    }
  }

  state csplit : addr, endp, hub, port {
    want CSPLIT HubAddr:hub Port:port {
      transition csplit_setup addr endp hub port;
    }
  }

  state csplit_setup : addr, endp, hub, port {
    want SETUP ADDR:addr EndPoint:endp {
      transition csplit_handshake addr endp hub port;
    }
  }

  state csplit_handshake : addr, endp, hub, port {
    want NYET {
      transition csplit addr endp hub port;
    }
    need ACK {
      success;
    }
  }

  state setup_ack {
    need ACK {
      success;
    }
  }
}

transaction BulkTransactionIn : ADDR, EndPoint, data {
  state bulkin_run {
    want IN {
      spawn bulkin_run;
      capture ADDR ADDR;
      capture EndPoint EndPoint;
      transition bulkin_data;
    }
  }

  state bulkin_data {
    need pid_type:DATA {
      capture data data;
      transition bulkin_ack;
    }
  }

  state bulkin_ack {
    need ACK {
      success;
    }
  }
}

transaction BulkTransactionOut : ADDR, EndPoint, data {
  state bulkout_run {
    want OUT {
      spawn bulkout_run;
      capture ADDR ADDR;
      capture EndPoint EndPoint;
      transition bulkout_data;
    }
  }

  state bulkout_data {
    need pid_type:DATA {
      capture data data;
      transition bulkout_ack;
    }
  }

  state bulkout_ack {
    need ACK {
      success;
    }
  }
}

transfer ControlTransfer : ADDR, EndPoint, setup, data {
  state ct_run {
    want SetupTransaction {
      capture ADDR ADDR;
      capture EndPoint EndPoint;
      capture setup setup;
      want setup.bmRequestType.transferDirection:0 {
        spawn ct_run;
        transition ct_dataout0 ADDR EndPoint setup.wLength nil;
      }
      need setup.bmRequestType.transferDirection:1 {
        spawn ct_run;
        transition ct_datain0 ADDR EndPoint setup.wLength nil;
      }
    }
  }

  state ct_datain0 : addr, endp, bytes_left, bytes {
    want ADDR:addr EndPoint:endp {
      want bytes_left:0 {
        need BulkTransactionOut data.length:0 {
          capture data bytes;
          success;
        }
      }
      need BulkTransactionIn {
        dec bytes_left data.length;
        append bytes data;
        transition ct_datain0 addr endp bytes_left bytes;
      }
    }
  }
  state ct_dataout0 : addr, endp, bytes_left, bytes {
    want ADDR:addr EndPoint:endp {
      want bytes_left:0 {
        need BulkTransactionIn data.length:0 {
          capture data bytes;
          success;
        }
      }
      need BulkTransactionOut {
        dec bytes_left data.length;
        append bytes data;
        transition ct_dataout0 addr endp bytes_left bytes;
      }
    }
  }
}
